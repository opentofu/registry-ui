package providerdocsource

import (
	"context"
	"testing"
)

/*

var normalizeRe = regexp.MustCompile("[^a-zA-Z0-9-_.]]")

//removes bad characters from filenames that we may come across

func normalizeName(name string) string {
	return normalizeRe.ReplaceAllString(name, "")
}
*/

func TestNormalizeName(t *testing.T) {
	tests := []struct {
		name     string
		input    string
		expected string
	}{
		{
			name:     "empty",
			input:    "",
			expected: "",
		},
		{
			name:     "no change",
			input:    "abc123",
			expected: "abc123",
		},
		{
			name:     "remove special characters",
			input:    "a!@#$%^&*()b",
			expected: "ab",
		},
		{
			name:     "remove spaces",
			input:    "a b c d",
			expected: "abcd",
		},
		{
			name:     "remove brackets",
			input:    "a(b)c[d]e{f}",
			expected: "abcdef",
		},
		{
			name:     "remove non-ascii characters",
			input:    "aébçd",
			expected: "abd",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			actual := normalizeName(tt.input)
			if actual != tt.expected {
				t.Errorf("expected %q, got %q", tt.expected, actual)
			}
		})
	}
}

func TestExtractFrontmatterPermissively(t *testing.T) {
	emptyDocItem := &DocumentationItem{
		Name:        "",
		Title:       "",
		Subcategory: "",
		Description: "",
		contents:    nil,
	}

	tests := []struct {
		name     string
		input    string
		expected *DocumentationItem
	}{
		{
			name:     "empty_string",
			input:    "",
			expected: emptyDocItem,
		},
		{
			name:     "no_frontmatter",
			input:    "hello world",
			expected: emptyDocItem,
		},
		{
			name: "valid_frontmatter",
			input: `---
page_title: Hello
subcategory: World
description: This is a test
---
hello world`,
			expected: &DocumentationItem{
				Name:        "",
				Title:       "Hello",
				Subcategory: "World",
				Description: "This is a test",
				contents:    []byte(""),
			},
		},
		{
			name: "invalid_frontmatter should skip",
			input: `---
					page_titleismissinghere
					subcategory: World
					---`,
			expected: &DocumentationItem{
				Name:        "",
				Title:       "",
				Subcategory: "World",
				Description: "",
				contents:    []byte(""),
			},
		},
		{
			name: "test",
			input: `---
layout: "tfe"
page_title: "Terraform Enterprise: tfe_project"
description: |-
Manages projects.
---


<!-- Please do not edit this file, it is generated. -->
# tfe_project
`,
			expected: &DocumentationItem{
				Name:        "",
				Title:       "Terraform Enterprise: tfe_project",
				Subcategory: "",
				Description: "Manages projects.",
				contents:    []byte(""),
			},
		},
	}

	for _, tt := range tests {
		s := source{
			logger:          nil,
			licenseDetector: nil,
		}
		t.Run(tt.name, func(t *testing.T) {
			doc := &DocumentationItem{}
			if err := s.ExtractFrontmatterPermissively(context.Background(), []byte(tt.input), doc); err != nil {
				t.Errorf("Failed to extract frontmatter: (%v)", err)
			}

			if doc.Name != tt.expected.Name {
				t.Errorf("expected %q, got %q", tt.expected.Name, doc.Name)
			}
			if doc.Title != tt.expected.Title {
				t.Errorf("expected %q, got %q", tt.expected.Title, doc.Title)
			}
			if doc.Subcategory != tt.expected.Subcategory {
				t.Errorf("expected %q, got %q", tt.expected.Subcategory, doc.Subcategory)
			}
			if doc.Description != tt.expected.Description {
				t.Errorf("expected %q, got %q", tt.expected.Description, doc.Description)
			}
			if string(doc.contents) != string(tt.expected.contents) {
				t.Errorf("expected %q, got %q", tt.expected.contents, doc.contents)
			}
		})
	}
}
